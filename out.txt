```main.cpp
#include <QApplication>
#include "MainWindow.hpp"

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    MainWindow window;
    window.show();

    return app.exec();
}
```

```MainWindow.cpp
#include "MainWindow.hpp"
#include <QVBoxLayout>
#include <QApplication>
#include <QKeyEvent>
#include <QLabel>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent) {
    // Create the text input fields
    functionInput1 = new QLineEdit(this);
    functionInput1->setPlaceholderText("Enter function 1 (e.g., sin(x))");
    functionInput2 = new QLineEdit(this);
    functionInput2->setPlaceholderText("Enter function 2 (e.g., cos(x))");
    functionInput3 = new QLineEdit(this);
    functionInput3->setPlaceholderText("Enter function 3 (e.g., tan(x))");
    functionInput4 = new QLineEdit(this);
    functionInput4->setPlaceholderText("Enter function 4 (e.g., exp(x))");
    functionInput5 = new QLineEdit(this);
    functionInput5->setPlaceholderText("Enter function 5 (e.g., log(x))");

    // Create the plot button
    plotButton = new QPushButton("Plot", this);
    connect(plotButton, &QPushButton::clicked, this, &MainWindow::plotFunction);

    // Create the quit button
    quitButton = new QPushButton("Quit", this);
    connect(quitButton, &QPushButton::clicked, this, &MainWindow::quitApplication);

    // Create the plot widget
    plotWidget = new PlotWidget(this);

    // Create a layout
    QVBoxLayout *layout = new QVBoxLayout;

    // Add widgets to the layout
    layout->addWidget(functionInput1);
    layout->addWidget(functionInput2);
    layout->addWidget(functionInput3);
    layout->addWidget(functionInput4);
    layout->addWidget(functionInput5);
    layout->addWidget(plotButton);
    layout->addWidget(quitButton);
    layout->addWidget(plotWidget);

    // Set the layout to the central widget
    QWidget *centralWidget = new QWidget(this);
    centralWidget->setLayout(layout);
    setCentralWidget(centralWidget);
}

MainWindow::~MainWindow() {
}

void MainWindow::plotFunction() {
    QStringList functionTexts;
    functionTexts << functionInput1->text() << functionInput2->text()
                  << functionInput3->text() << functionInput4->text()
                  << functionInput5->text();
    plotWidget->setFunctions(functionTexts);
    plotWidget->repaint();
}

void MainWindow::quitApplication() {
    qApp->quit();
}

void MainWindow::keyPressEvent(QKeyEvent *event) {
    if (event->key() == Qt::Key_Return || event->key() == Qt::Key_Enter) {
        plotFunction();
    } else if (event->modifiers() == Qt::ControlModifier && event->key() == Qt::Key_Q) {
        quitApplication();
    } else {
        QMainWindow::keyPressEvent(event);
    }
}
```

```MainWindow.hpp
#ifndef MAINWINDOW_HPP
#define MAINWINDOW_HPP

#include <QMainWindow>
#include <QLineEdit>
#include <QPushButton>
#include "PlotWidget.hpp"

class MainWindow : public QMainWindow {
    Q_OBJECT

public:
    MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

protected:
    void keyPressEvent(QKeyEvent *event) override;

private slots:
    void plotFunction();
    void quitApplication();

private:
    QLineEdit *functionInput1;
    QLineEdit *functionInput2;
    QLineEdit *functionInput3;
    QLineEdit *functionInput4;
    QLineEdit *functionInput5;
    QPushButton *plotButton;
    QPushButton *quitButton;
    PlotWidget *plotWidget;
};

#endif // MAINWINDOW_HPP
```

```Parser.cpp
```

```Parser.hpp
// Parser.hpp

#pragma once

#include <unordered_map>
#include <functional>
#include <cmath>
#include <string>

using MathFunction = std::function<double(double)>;

const std::unordered_map<std::string, MathFunction> mathFunctions = {
    {"sin", [](double x) { return std::sin(x); }},
    {"cos", [](double x) { return std::cos(x); }},
    {"tan", [](double x) { return std::tan(x); }},
    {"asin", [](double x) { return std::asin(x); }},
    {"acos", [](double x) { return std::acos(x); }},
    {"atan", [](double x) { return std::atan(x); }},
    {"sinh", [](double x) { return std::sinh(x); }},
    {"cosh", [](double x) { return std::cosh(x); }},
    {"tanh", [](double x) { return std::tanh(x); }},
    {"exp", [](double x) { return std::exp(x); }},
    {"log", [](double x) { return std::log(x); }},
    {"log10", [](double x) { return std::log10(x); }},
    {"sqrt", [](double x) { return std::sqrt(x); }},
    // {"pow", [](double x, double y) { return std::pow(x, y); }},
    {"fabs", [](double x) { return std::fabs(x); }},
    {"ceil", [](double x) { return std::ceil(x); }},
    {"floor", [](double x) { return std::floor(x); }},
    {"round", [](double x) { return std::round(x); }},
    // {"fmod", [](double x, double y) { return std::fmod(x, y); }} 
};
```

```PlotWidget.cpp
#include "PlotWidget.hpp"
#include "Parser.hpp"
#include <QPainter>
#include <QPainterPath>
#include <QWheelEvent>
#include <QMouseEvent>
#include <cmath>

PlotWidget::PlotWidget(QWidget *parent)
    : QWidget(parent), m_scale(50.0), m_offsetX(0.0), m_offsetY(0.0) {
    m_functionColors = {Qt::red, Qt::blue, Qt::green, Qt::magenta, Qt::cyan};
}

QSize PlotWidget::sizeHint() const {
    return QSize(800, 600);
}

void PlotWidget::setFunctions(const QStringList &functionTexts) {
    m_functionTexts.clear();
    for (const auto &text : functionTexts) {
        if (!text.isEmpty()) {
            m_functionTexts.append(text);
        }
    }
    repaint();
}

void PlotWidget::paintEvent(QPaintEvent *event) {
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing, true);

    int w = width();
    int h = height();

    painter.setWindow(-w / 2 + m_offsetX, -h / 2 + m_offsetY, w, h);

    // Draw infinite axes
    QPen axisPen(Qt::black, 1, Qt::DashLine);
    painter.setPen(axisPen);

    // Draw x-axis
    painter.drawLine(m_offsetX - w, 0, m_offsetX + w, 0);

    // Draw y-axis
    painter.drawLine(0, m_offsetY - h, 0, m_offsetY + h);

    // Draw ticks and numbers on axes
    const int tickSpacing = 50;
    QFont font("Arial", 8);
    painter.setFont(font);
    painter.setPen(Qt::black);

    // Draw x-axis ticks and numbers
    for (int i = m_offsetX / tickSpacing - w / tickSpacing; i <= m_offsetX / tickSpacing + w / tickSpacing; ++i) {
        int x = i * tickSpacing;
        painter.drawLine(x, -5, x, 5);
        if (x != 0) {
            painter.drawText(x - 10, 15, QString::number(x / m_scale, 'f', 1));
        }
    }

    // Draw y-axis ticks and numbers
    for (int i = m_offsetY / tickSpacing - h / tickSpacing; i <= m_offsetY / tickSpacing + h / tickSpacing; ++i) {
        int y = i * tickSpacing;
        painter.drawLine(-5, y, 5, y);
        if (y != 0) {
            painter.drawText(10, y + 5, QString::number(-y / m_scale, 'f', 1));
        }
    }

    // Draw the functions
    for (int i = 0; i < m_functionTexts.size(); ++i) {
        const QString &functionText = m_functionTexts[i];
        QColor color = m_functionColors[i % m_functionColors.size()];
        painter.setPen(color);

        QPainterPath path;
        double step = 0.1;
        bool firstPoint = true;
        for (double x = m_offsetX - w / 2; x <= m_offsetX + w / 2; x += step * m_scale) {
            double y = evaluateFunction((x) / m_scale, functionText) * m_scale;
            if (firstPoint) {
                path.moveTo(x, -y);
                firstPoint = false;
            } else {
                path.lineTo(x, -y);
            }
        }
        painter.drawPath(path);
    }
}

void PlotWidget::wheelEvent(QWheelEvent *event) {
    adjustScale(event->angleDelta().y());
    repaint();
}

void PlotWidget::mousePressEvent(QMouseEvent *event) {
    if (event->button() == Qt::LeftButton) {
        m_lastPos = event->pos();
    }
}

void PlotWidget::mouseMoveEvent(QMouseEvent *event) {
    if (event->buttons() & Qt::LeftButton) {
        int dx = event->x() - m_lastPos.x();
        int dy = event->y() - m_lastPos.y();
        m_offsetX -= dx;
        m_offsetY -= dy;
        m_lastPos = event->pos();
        repaint();
    }
}

void PlotWidget::mouseReleaseEvent(QMouseEvent *event) {
    if (event->button() == Qt::LeftButton) {
        // Do nothing for now
    }
}

void PlotWidget::adjustScale(int delta) {
    constexpr double scaleFactor = 1.1;
    if (delta > 0) {
        m_scale *= scaleFactor;
    } else {
        m_scale /= scaleFactor;
    }
}

double PlotWidget::evaluateFunction(double x, const QString &functionText) {
    if (functionText.isEmpty()) return 0.0;
    auto it = mathFunctions.find(functionText.toStdString());
    if (it != mathFunctions.end()) {
        double result = it->second(x);
        return result;
    }
    return 0.0;
}
```

```PlotWidget.hpp
#ifndef PLOTWIDGET_HPP
#define PLOTWIDGET_HPP

#include <QWidget>
#include <QPointF>
#include <QStringList>
#include <QVector>
#include <QColor>

class PlotWidget : public QWidget {
    Q_OBJECT

public:
    PlotWidget(QWidget *parent = nullptr);
    QSize sizeHint() const override;
    void setFunctions(const QStringList &functionTexts);

protected:
    void paintEvent(QPaintEvent *event) override;
    void wheelEvent(QWheelEvent *event) override;
    void mousePressEvent(QMouseEvent *event) override;
    void mouseMoveEvent(QMouseEvent *event) override;
    void mouseReleaseEvent(QMouseEvent *event) override;

private:
    QStringList m_functionTexts;
    QVector<QColor> m_functionColors;
    double m_scale;
    double m_offsetX;
    double m_offsetY;
    QPointF m_lastPos;
    double evaluateFunction(double x, const QString &functionText);
    void adjustScale(int delta);
};

#endif // PLOTWIDGET_HPP
```

